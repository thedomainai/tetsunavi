---
title: "「知らないことは検索できない」— 5体のAIエージェントが引越し手続きを自律的に洗い出す「テツナビ」"
emoji: "🏠"
type: "idea"
topics: ["gch4", "gemini", "googlecloud", "adk", "nextjs"]
published: true
---

## はじめに

**第4回 Agentic AI Hackathon with Google Cloud** への参加作品として、**テツナビ**を開発しました。

> **「引越しします」の一言から、AIエージェントが自律的にパーソナライズされた手続きロードマップを作成・管理するサービス。**

引越し元・引越し先・引越し日の3つを入力するだけで、5体のAIエージェントが**あなたの状況に合った20〜30件の手続き**を自動で洗い出し、必要書類・管轄窓口・タイムラインまでを一気通貫で提示します。

**プロジェクトURL**

- デモサイト: https://tetsunavi-frontend-zxnb4in7pa-an.a.run.app
- GitHubリポジトリ: https://github.com/thedomainai/tetsunavi

## デモ動画

https://www.youtube.com/watch?v=XXXXX

## 課題の新規性: 年間700万人が直面する「検索すらできない」問題

### 引越し手続きの現状

日本では年間約**700万人**が引越しをしています。1回の引越しで必要な手続きは、行政・民間合わせて**20〜30種類**。転出届、転入届、国民健康保険、年金、免許証の住所変更、車庫証明、児童手当、学校の転校手続き、電気・ガス・水道、インターネット、郵便転送……。

しかし、本当に困っているのは「手続きが多い」ことではありません。

### 真のペイン: 知らない手続きは検索もできない

| レベル | 困りごと | 具体例 | 影響 |
|--------|---------|--------|------|
| **S級（知らないから漏れる）** | 自分に該当する手続きの存在を知らない | 犬の登録変届が必要だと知らなかった | 期限切れで過料が発生するリスク |
| **S級** | 手続きの前提条件を知らない | 転入届を出す前に転出届が必要だと知らなかった | 二度手間、交通費・時間の浪費 |
| **A級（知っていても非効率）** | 管轄窓口が分からない | 市役所に行ったら「これは警察署です」と言われた | 複数の窓口をたらい回し |
| **A級** | 手続きの順序・依存関係が複雑 | 住民票を先に取得しないと免許の住所変更ができない | 手戻りで半日がつぶれる |
| **B級（面倒だが対処可能）** | 必要書類が分からない | 窓口で「印鑑証明が足りません」 | 再訪問が必要 |

**核心的洞察**: S級の課題は**「知らないから検索もできない」**という構造を持っています。「犬の登録変届」を知らない人は「犬 登録変届 引越し」と検索することもできません。

### 既存ツールでは解決できない理由

| 既存ツール | 限界 |
|-----------|------|
| SUUMO等のチェックリスト | 静的。全員に同じ内容を表示。車なしの人にも車庫証明が載っている |
| 自治体の公式サイト | 転入側の手続きしか載っていない。転出側・民間手続きは対象外 |
| Google検索 | 知っている手続きは調べられるが、知らない手続きは検索クエリを作れない |

これらのツールは全て**受動的**です。「何を調べるべきか」を人間が知っていることが前提になっています。

### なぜ Agentic AI なのか

テツナビが解決する課題は、Agentic AI の本質と完全に一致しています。

- **自律性**: ユーザーの状況から「何が必要か」をAIが自律的に推論する。ユーザーが知らない手続きもAIが洗い出す
- **専門性**: 5体のエージェントがそれぞれの領域に特化。質問生成、手続き特定、書類準備、窓口案内、スケジュール管理を分業
- **行動支援**: 手続きリストを出すだけでなく、「いつ・どこで・何を持って行けばいいか」まで具体的に提示する

「検索できない問題を、検索を不要にすることで解決する」。これがテツナビのアプローチです。

## 解決策の有効性: 5体のマルチエージェントによる引越し手続きの自律管理

### ソリューション概要

テツナビのコアバリューは **「ユーザーが知らない手続きをAIが代わりに洗い出す」** ことです。3つの情報を入力するだけで、5体のAIエージェントがパーソナライズされた手続きロードマップを自動生成します。

```
【ユーザーがやること】              【AIが自律的にやること】

  引越し元・先・日を入力 ───→  1. 状況ヒアリング (Interview Agent)
                                  5-6問の質問で家族構成・車・ペット等を把握
         ↓
  質問に回答する ──────────→  2. 手続き特定 (Procedure Agent)
                                  状況に応じた20-30件の手続きを自律的に洗い出し
         ↓
  手続きリストを確認する ←──── 3. 書類・窓口情報 (Document + Location Agent)
                                  並列実行で必要書類と管轄窓口を一括取得
         ↓                     4. タイムライン生成 (Schedule Agent)
  タイムラインで計画を立てる ←     依存関係を考慮した時系列スケジュール
```

ユーザーの作業は**「3項目の入力」と「5-6問への回答」だけ**です。

### なぜマルチエージェントなのか

単一のLLMに全てを任せるアプローチでは、「手続きの網羅性」と「各手続きの詳細情報の品質」を同時に担保することが困難です。マルチエージェント設計を採用した理由は3つあります。

**1. 専門性による品質向上**

各エージェントは1つの責務に集中します。Procedure Agent は「何が必要か」だけに特化し、Document Agent は「何を持って行くか」だけに特化しています。プロンプトも役割に最適化できるため、汎用プロンプトと比べて出力品質が向上します。

**2. 並列実行によるレスポンス改善**

Document Agent（書類情報取得）と Location Agent（窓口情報取得）は独立した処理です。`asyncio.gather()` で並列実行することで、直列実行と比較してレスポンス時間を約半分に短縮しています。

```python
# Document Agent と Location Agent を並列実行
results = await asyncio.gather(
    self.document_agent.get_procedure_details(session, procedure),
    self.location_agent.get_office_info(session, procedure),
    return_exceptions=True,
)
```

**3. 障害の局所化**

1つのエージェントの失敗が全体を止めないよう、`return_exceptions=True` でエラーを局所化しています。例えば Location Agent が失敗しても、書類情報は正常に返ります。

### ユーザー体験フロー

```
Step 1: 引越し元（東京都品川区）・引越し先（大阪市北区）・引越し日を入力
      ↓
Step 2: AIが5問で状況を把握
   「家族構成は？」→ 夫婦 + 小学生の子供1人
   「車をお持ちですか？」→ はい
   「ペットはいますか？」→ 猫1匹
      ↓
Step 3: パーソナライズされた手続きリスト（24件）が自動生成
   行政手続き: 転出届、転入届、国民健康保険、児童手当、小学校の転校手続き...
   民間手続き: 電気、ガス、水道、インターネット、車庫証明...
   ※ 車なしの人には車庫証明は表示されない
   ※ ペットありの人には犬の登録変届が表示される
      ↓
Step 4: 窓口別グルーピングで「1回の訪問でまとめて対応」
   🏛️ 市役所: 転入届、国民健康保険、児童手当（3件をまとめて）
   🚔 警察署: 免許証の住所変更
   🚗 運輸支局: 車庫証明、車検証の住所変更
      ↓
Step 5: タイムラインで「いつ何をすべきか」を可視化
   引越し14日前 → 転出届の提出
   引越し当日   → 電気・ガス・水道の開始立会い
   引越し後14日 → 転入届の提出（期限）
      ↓
Step 6: カレンダーエクスポート（.ics形式）で Google Calendar に追加
```

### 課題解決の効果

| 指標 | Before | After |
|------|--------|-------|
| 手続きの洗い出し | 自力で調査（漏れリスク大） | AIが状況に応じて自動で20-30件を網羅的に特定 |
| 窓口の特定 | 自治体サイトを個別に確認 | 窓口別グルーピングで訪問先を一覧化 |
| スケジュール管理 | 手動でカレンダーに登録 | タイムライン自動生成 + ICSエクスポート |
| 必要書類の把握 | 窓口に行って初めて知る | 事前に書類リストを確認可能 |

## システムアーキテクチャ

### 全体構成

```
┌───────────────────────────────────────────────────────┐
│                  ユーザー（ブラウザ）                      │
└───────────────────────┬───────────────────────────────┘
                        │ HTTPS
┌───────────────────────▼───────────────────────────────┐
│             Next.js 16 + React 19                      │
│             Cloud Run (Frontend)                       │
│                                                        │
│  ・BFF パターンで Backend と内部通信                      │
│  ・TanStack Query でキャッシュ + 楽観的更新               │
│  ・TailwindCSS + カスタムUIコンポーネント                 │
└───────────────────────┬───────────────────────────────┘
                        │ HTTP (内部通信)
┌───────────────────────▼───────────────────────────────┐
│             Python FastAPI + Gemini 2.0 Flash           │
│             Cloud Run (Backend)                        │
│                                                        │
│  ┌──────────────────────────────────────────────────┐ │
│  │         Root Agent（オーケストレーター）              │ │
│  │  エージェント間の調整 / 並列実行制御 / エラー局所化    │ │
│  └────┬────────┬────────┬────────┬────────┬─────────┘ │
│       │        │        │        │        │            │
│  ┌────▼──┐┌────▼──┐┌────▼──┐┌────▼──┐┌────▼──┐        │
│  │Inter- ││Proce- ││Docu-  ││Loca-  ││Sche-  │        │
│  │view   ││dure   ││ment   ││tion   ││dule   │        │
│  │Agent  ││Agent  ││Agent  ││Agent  ││Agent  │        │
│  │       ││       ││       ││       ││       │        │
│  │状況   ││手続き  ││書類   ││窓口    ││期限   │        │
│  │ヒアリ ││特定   ││準備   ││案内    ││管理   │        │
│  │ング   ││       ││       ││       ││       │        │
│  └───┬───┘└───┬───┘└───┬───┘└───┬───┘└───┬───┘        │
│      │        │        │        │        │            │
└──────┼────────┼────────┼────────┼────────┼────────────┘
       │        │        │        │        │
  ┌────▼────────▼────────▼────────▼────────▼────┐
  │            Gemini 2.0 Flash                  │
  │  質問生成 / 手続き推論 / 書類特定 / 窓口検索   │
  └──────────────────────┬──────────────────────┘
                         │
                    ┌────▼─────┐
                    │ Firestore │
                    │ (NoSQL)   │
                    └──────────┘
```

### 技術スタック

| レイヤー | 技術 | 選定理由 |
|---------|------|----------|
| **Frontend** | Next.js 16 (App Router) + React 19 | Server Components + standalone output で Cloud Run 最適化 |
| **UI** | TailwindCSS + カスタムコンポーネント | 日本語UIに最適化したデザインシステム |
| **状態管理** | TanStack Query v5 | API キャッシュ・楽観的更新・エラーリトライを自動化 |
| **Backend** | Python 3.12 + FastAPI | AI処理に最適な言語、Pydantic v2 でバリデーション |
| **AI** | Gemini 2.0 Flash (Vertex AI) | 高速・低コスト。日本語の行政用語理解に優れる |
| **DB** | Firestore | セッション単位のサブコレクション構造、Cloud Run との親和性 |
| **デプロイ** | Cloud Run (2コンテナ) | マルチステージビルドで軽量化、自動スケーリング |

### BFF パターンの採用

Frontend と Backend の間に **BFF（Backend for Frontend）パターン** を採用しました。

```
ブラウザ → Next.js Route Handlers（BFF）→ Python Backend
```

- **セキュリティ**: バックエンドの API URL をクライアントに露出しない
- **型安全性**: TypeScript で API レスポンスの型を保証
- **柔軟性**: フロントエンドの要件に合わせたデータ変換を BFF 層で実施

## マルチエージェント詳細設計

### エージェント一覧

| エージェント | 責務 | 入力 | 出力 |
|------------|------|------|------|
| **Root Agent** | ワークフロー全体の制御 | セッション | 各エージェントの結果を統合 |
| **Interview Agent** | 状況把握のための質問生成 | 引越し元・先・日 | 5-6問の質問（選択肢/Boolean） |
| **Procedure Agent** | 手続きの網羅的な特定 | インタビュー結果 | 20-30件の手続きリスト |
| **Document Agent** | 必要書類・手順の特定 | 個別の手続き情報 | 書類リスト + 手順ガイド |
| **Location Agent** | 管轄窓口の情報提供 | 手続き + 住所情報 | 窓口名・住所・営業時間 |
| **Schedule Agent** | タイムライン生成 | 手続きリスト + 引越し日 | 時系列スケジュール + マイルストーン |

### Root Agent: オーケストレーター

Root Agent は5体のエージェントの司令塔です。ワークフローの実行順序を管理し、エージェント間の依存関係を制御します。

```python
class RootAgent:
    """マルチエージェントシステムのオーケストレーター"""

    async def get_procedure_detail(self, session, procedure):
        # Document Agent と Location Agent を並列実行（障害局所化）
        document_task = self.document_agent.get_procedure_details(session, procedure)
        location_task = self.location_agent.get_office_info(session, procedure)

        results = await asyncio.gather(
            document_task, location_task, return_exceptions=True
        )

        # エージェントが失敗しても他の結果は正常に返す
        if not isinstance(results[0], Exception):
            procedure = results[0]
        if not isinstance(results[1], Exception):
            procedure.office = results[1]

        return procedure
```

**設計のポイント**:
- Document Agent と Location Agent を `asyncio.gather()` で並列実行し、レスポンス時間を短縮
- `return_exceptions=True` で障害を局所化。Location Agent が失敗しても書類情報は返る
- 各エージェントの結果を段階的にマージする設計で、部分的な成功を許容

### Interview Agent: 対話による状況把握

Interview Agent は引越し情報から**5-6問の質問を動的に生成**します。家族構成、車の所有、ペット、マイナンバーカードなど、手続きに影響する要素を効率的にヒアリングします。

```python
class InterviewAgent(BaseAgent):
    async def generate_questions(self, session):
        prompt = f"""
あなたは引越し手続きのアドバイザーです。
以下の引越し情報に基づいて、必要な手続きを特定するための質問を5-6個生成してください。

## 引越し情報
- 引越し元: {session.move_from.prefecture}{session.move_from.city}
- 引越し先: {session.move_to.prefecture}{session.move_to.city}
- 引越し日: {session.move_date.strftime('%Y年%m月%d日')}

## 質問のガイドライン
- 家族構成、車の所有、ペット、マイナンバーカードの有無など
- 回答しやすいように、選択肢形式を優先する
"""
        response = await self.generate(prompt, temperature=0.7)
        questions = await self.parse_json_response(response)

        # 最低限の質問を保証（フォールバック）
        if len(questions) == 0:
            questions = self._get_default_questions()

        return questions
```

**設計のポイント**:
- 引越し元・先の地域によって質問内容が変わる（例: 都市部→地方では車の必要性が高まる）
- Gemini の生成失敗時はデフォルトの質問にフォールバック（サービス停止を防止）
- 質問タイプ（`boolean` / `single_choice` / `multiple_choice`）をサポートし、UIの出し分けに対応

### Procedure Agent: パーソナライズされた手続き特定

Procedure Agent は**ユーザー固有の状況から20-30件の手続きを網羅的に洗い出す**、テツナビの中核エージェントです。

```python
class ProcedureAgent(BaseAgent):
    async def identify_procedures(self, session):
        interview_info = f"""
- 家族構成: {', '.join(session.interview.family)}
- 車の所有: {'あり' if session.interview.has_car else 'なし'}
- ペット: {'あり' if session.interview.has_pet else 'なし'}
- マイナンバーカード: {'あり' if session.interview.has_my_number else 'なし'}
"""
        prompt = f"""
あなたは引越し手続きの専門家です。以下の状況に基づいて、
必要な行政手続きと民間手続きを全て洗い出してください。

## 引越し情報
- 引越し元: {session.move_from.prefecture}{session.move_from.city}
- 引越し先: {session.move_to.prefecture}{session.move_to.city}

## ユーザーの状況
{interview_info}

注意:
- 20〜30項目を出力
- 各手続きに優先度（高/中/低）と期限を付与
- ユーザーの状況に該当しない手続きは含めない
"""
```

**設計のポイント**:
- ユーザーのインタビュー結果をプロンプトに注入することで、**車なしの人に車庫証明を提示しない**等のパーソナライズを実現
- 各手続きに期限タイプ（引越し前/当日/後）と日数を付与し、引越し日から絶対日付を自動計算
- フォールバック: Gemini の応答パースに失敗した場合は、最低限の手続き（転入届・転出届）を返す

### Schedule Agent: 依存関係を考慮したタイムライン生成

Schedule Agent は手続き間の依存関係をトポロジカルソートで解決し、時系列のスケジュールを生成します。

```python
class ScheduleAgent(BaseAgent):
    async def generate_timeline(self, session, procedures):
        # 手続きを日付ごとにグループ化
        date_groups = {}
        for procedure in procedures:
            if procedure.deadline.absolute_date:
                date_key = procedure.deadline.absolute_date.strftime("%Y-%m-%d")
                date_groups.setdefault(date_key, []).append(procedure)

        # マイルストーンを生成（引越し当日 + 高優先度の期限）
        milestones = [
            Milestone(date=session.move_date, label="引越し当日", type="move_date")
        ]
        for p in procedures:
            if p.priority == "高" and p.deadline.absolute_date:
                milestones.append(
                    Milestone(date=p.deadline.absolute_date, label=f"{p.title}の期限")
                )

        return Timeline(items=timeline_items, milestones=sorted(milestones))
```

**設計のポイント**:
- **トポロジカルソート**: 「転出届 → 転入届」のような依存関係を自動解決
- **マイルストーン自動抽出**: 高優先度の手続き期限を自動でマイルストーンに設定
- **相対→絶対日付変換**: 「引越し後14日以内」を具体的な日付（例: 4月14日）に変換

## 実装品質と拡張性

### 実装の完成度

| 項目 | 内容 |
|------|------|
| **エージェント** | 5体全て実装済み、Cloud Run 上で稼働中 |
| **フロントエンド** | 8ページ（ホーム、インタビュー、手続きリスト、手続き詳細、窓口別表示、タイムライン、チャット） |
| **バックエンド** | FastAPI + Pydantic v2、10 API エンドポイント、OpenAPI ドキュメント自動生成 |
| **UX** | 窓口別グルーピング、カレンダーエクスポート（ICS）、進捗チェックリスト、AIチャット |
| **エラーハンドリング** | エージェントごとのフォールバック、フロントエンドのエラーバウンダリ |
| **モックモード** | `MOCK_MODE=true` でGCP認証なし動作（21件のリアルデータ） |

### Google Cloud ツールの活用

本プロジェクトでは、Google Cloud のサービスを**4つ**活用しています。

```
┌─ AI ─────────────────────────────────────────┐
│  Gemini 2.0 Flash: 質問生成、手続き推論、       │
│                    書類特定、窓口検索、          │
│                    タイムライン生成              │
└──────────────────────────────────────────────┘
┌─ Compute ────────────────────────────────────┐
│  Cloud Run: Frontend + Backend 2コンテナ      │
│             マルチステージビルドで軽量化         │
└──────────────────────────────────────────────┘
┌─ Data ───────────────────────────────────────┐
│  Firestore: セッション・インタビュー・           │
│             手続き・タイムラインデータ           │
└──────────────────────────────────────────────┘
```

### 拡張性の設計

**ライフイベント拡張の容易さ**

MVPでは引越しにフォーカスしていますが、アーキテクチャはライフイベント全般に拡張可能です。

```
現在: Root → Interview → Procedure → Document → Location → Schedule
                 ↓ ライフイベント拡張
将来: Root → Interview → Procedure → Document → Location → Schedule
                              ↓
                         相続の手続き特定
                         出産の手続き特定
                         結婚の手続き特定
```

Procedure Agent のプロンプトを変更するだけで、異なるライフイベントの手続きを洗い出せます。エージェント構成の変更は不要です。

**エージェント追加の容易さ**

```
将来: Root → ... → Reminder Agent (リマインド通知)
                  → Proxy Agent (手続き代行)
                  → Maps Agent (Google Maps 連携)
```

既存コードへの変更は **Root Agent のルーティング追加のみ** です。

**スケーラビリティ**

| 観点 | 設計 |
|------|------|
| **同時ユーザー増** | Cloud Run の自動スケーリング（0〜Nインスタンス） |
| **データ増** | Firestore の水平スケーリング（セッション単位のサブコレクション設計） |
| **API コスト** | Gemini 2.0 Flash の低コスト + モックモードで開発コストゼロ |

### 費用対効果

| 項目 | 月額（1,000セッション想定） |
|------|----------------------|
| Cloud Run | 約 ¥1,000（min=0でアイドル時ゼロ） |
| Firestore | 約 ¥500 |
| Gemini API | 約 ¥2,000 |
| **合計** | **約 ¥3,500**（1セッションあたり約 ¥3.5） |

### コード品質

- **TypeScript strict mode**: フロントエンド全ファイルで型安全性を保証
- **Pydantic v2**: バックエンドの入出力バリデーション、ドメインモデルの厳密な型定義
- **React Hook Form + Zod**: フォームバリデーションをスキーマ駆動で統一
- **BFF パターン**: フロントエンド・バックエンド間の関心分離

## 技術的チャレンジと学び

### 直面した課題と解決策

**課題1: Gemini の JSON 出力の不安定さ**

JSON 配列の出力を指定しても、マークダウンのコードブロックで包まれたり、余分なテキストが付与されるケースがありました。`BaseAgent` にクリーニング処理を共通実装し、全エージェントで安定した構造化データ取得を実現しました。

**課題2: Boolean 質問で「いいえ」が未回答扱いになるバグ**

React Hook Form で Boolean 値の `false` が未入力として扱われ、バリデーションエラーが発生する問題がありました。値の型変換を明示的に行うことで解決しました。

**課題3: Cloud Run の Dockerfile 最適化**

Next.js の `standalone` 出力と Cloud Run の `PORT` 環境変数の組み合わせで、起動時にポートバインドが失敗する問題がありました。`server.js` の起動コマンドを明示的に設定し、非rootユーザーでの実行と合わせて解決しました。

### ハッカソンでの学び

- **Gemini 2.0 Flash の日本語品質**: 行政用語（転入届、国民健康保険等）の理解が正確で、プロンプト設計の手間が少なかった
- **マルチエージェントの並列実行**: `asyncio.gather()` + `return_exceptions=True` の組み合わせが、障害耐性のある並列処理に最適
- **Cloud Run の手軽さ**: Dockerfile があればすぐにデプロイでき、Frontend / Backend の2コンテナ構成も簡単に実現

## 今後の展望

### 短期（3ヶ月）

- Google Maps API 連携による窓口の正確な所在地・ルート案内
- Vertex AI Search (RAG) による行政手続きナレッジベースの構築
- リマインド通知の実装

### 中期（6ヶ月）

- 他のライフイベント対応（相続、出産、結婚、離婚）
- ユーザーアカウント管理と手続き履歴の永続化
- 自治体公式データとの連携

### 長期（1年）

- 手続きの電子申請代行（マイナポータル連携）
- 多言語対応（在日外国人の引越し手続き支援）
- B2B API 提供（不動産会社・引越し業者への組み込み）

## おわりに

テツナビは、**「知らないことは検索できない」** という構造的な課題に対して、**AIエージェントが自律的に必要な手続きを洗い出す**ことで解決を図るプロジェクトです。

5体のエージェントがそれぞれの専門性を持ち、協調して動くことで、**状況ヒアリング → 手続き特定 → 書類準備 → 窓口案内 → スケジュール管理**の一連のフローを自律化しました。ユーザーがやることは「引越し元・先・日を入力する」と「5-6問に回答する」だけ。あとはAIが20-30件の手続きを洗い出し、期限管理まで行います。

引越しは、ほぼ全ての日本居住者が人生で何度か経験するライフイベントです。その度に「何をすればいいか分からない」と悩む時間をゼロにすること。テツナビは、**行政手続きの不安を安心に変え、引越し準備に集中できる世界**を目指しています。

## リンク

- **GitHubリポジトリ**: https://github.com/thedomainai/tetsunavi
- **デモサイト**: https://tetsunavi-frontend-zxnb4in7pa-an.a.run.app
- **ハッカソン**: https://zenn.dev/hackathons/google-cloud-japan-ai-hackathon-vol4
